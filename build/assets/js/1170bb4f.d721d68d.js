"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[342],{8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var s=i(6540);const r={},o=s.createContext(r);function t(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),s.createElement(o.Provider,{value:e},n.children)}},9638:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var s=i(4848),r=i(8453);const o={sidebar_position:4},t="URDF/SDF Formats: Robot Description and Simulation Formats",l={id:"module-2-digital-twin/urdf-sdf-formats",title:"URDF/SDF Formats: Robot Description and Simulation Formats",description:"Learning Objectives",source:"@site/docs/module-2-digital-twin/urdf-sdf-formats.md",sourceDirName:"module-2-digital-twin",slug:"/module-2-digital-twin/urdf-sdf-formats",permalink:"/ai-robotic-book/docs/module-2-digital-twin/urdf-sdf-formats",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/ai-robotic-book/tree/main/docs/module-2-digital-twin/urdf-sdf-formats.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Unity Simulation: High-Fidelity Visualization and Human-Robot Interaction",permalink:"/ai-robotic-book/docs/module-2-digital-twin/unity-simulation"},next:{title:"Sensor Simulation: LiDAR, Depth Cameras, and IMUs",permalink:"/ai-robotic-book/docs/module-2-digital-twin/sensor-simulation"}},a={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to URDF vs SDF",id:"introduction-to-urdf-vs-sdf",level:2},{value:"URDF: The Robot Description Format",id:"urdf-the-robot-description-format",level:2},{value:"URDF Overview",id:"urdf-overview",level:3},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"URDF Features",id:"urdf-features",level:3},{value:"URDF Limitations for Simulation",id:"urdf-limitations-for-simulation",level:3},{value:"SDF: The Simulation Description Format",id:"sdf-the-simulation-description-format",level:2},{value:"SDF Overview",id:"sdf-overview",level:3},{value:"SDF Structure",id:"sdf-structure",level:3},{value:"SDF Features",id:"sdf-features",level:3},{value:"Converting URDF to SDF",id:"converting-urdf-to-sdf",level:2},{value:"Using gazebo_ros_pkgs",id:"using-gazebo_ros_pkgs",level:3},{value:"Direct Conversion",id:"direct-conversion",level:3},{value:"Programmatic Conversion",id:"programmatic-conversion",level:3},{value:"Detailed Format Comparison",id:"detailed-format-comparison",level:2},{value:"Element Mapping",id:"element-mapping",level:3},{value:"SDF Extensions",id:"sdf-extensions",level:3},{value:"Physics Extensions",id:"physics-extensions",level:4},{value:"Sensor Definitions",id:"sensor-definitions",level:4},{value:"Plugin Integration",id:"plugin-integration",level:4},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Complete URDF to SDF Workflow",id:"complete-urdf-to-sdf-workflow",level:3},{value:"Advanced SDF Features",id:"advanced-sdf-features",level:3},{value:"Custom Sensors",id:"custom-sensors",level:4},{value:"Physics Materials",id:"physics-materials",level:4},{value:"Tools for Format Management",id:"tools-for-format-management",level:2},{value:"URDF Tools",id:"urdf-tools",level:3},{value:"SDF Tools",id:"sdf-tools",level:3},{value:"Xacro for Both Formats",id:"xacro-for-both-formats",level:3},{value:"Best Practices for Format Usage",id:"best-practices-for-format-usage",level:2},{value:"When to Use URDF",id:"when-to-use-urdf",level:3},{value:"When to Use SDF",id:"when-to-use-sdf",level:3},{value:"Combined Approach",id:"combined-approach",level:3},{value:"Example Workflow",id:"example-workflow",level:3},{value:"Exercise: Format Conversion and Integration",id:"exercise-format-conversion-and-integration",level:2},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"URDF to SDF Conversion Issues",id:"urdf-to-sdf-conversion-issues",level:3},{value:"Simulation Issues",id:"simulation-issues",level:3},{value:"Integration Issues",id:"integration-issues",level:3},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"urdfsdf-formats-robot-description-and-simulation-formats",children:"URDF/SDF Formats: Robot Description and Simulation Formats"}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand the differences between URDF and SDF formats"}),"\n",(0,s.jsx)(e.li,{children:"Convert between URDF and SDF for different simulation needs"}),"\n",(0,s.jsx)(e.li,{children:"Create SDF files for Gazebo simulation from URDF models"}),"\n",(0,s.jsx)(e.li,{children:"Work with both formats effectively in robotics applications"}),"\n",(0,s.jsx)(e.li,{children:"Choose the appropriate format for specific use cases"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-urdf-vs-sdf",children:"Introduction to URDF vs SDF"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})," and ",(0,s.jsx)(e.strong,{children:"SDF (Simulation Description Format)"})," are two XML-based formats used to describe robots and simulation environments. While URDF is primarily focused on robot structure for ROS, SDF is designed for comprehensive simulation environments in Gazebo."]}),"\n",(0,s.jsx)(e.p,{children:"Understanding both formats is crucial because:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"URDF"})," is used for robot description in ROS (kinematics, dynamics, visualization)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"SDF"})," is used for simulation environments in Gazebo (physics, sensors, world)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Conversion"})," between formats is often necessary for complete robotics workflows"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"urdf-the-robot-description-format",children:"URDF: The Robot Description Format"}),"\n",(0,s.jsx)(e.h3,{id:"urdf-overview",children:"URDF Overview"}),"\n",(0,s.jsx)(e.p,{children:"URDF is specifically designed for robot description and is deeply integrated with ROS. It focuses on describing the robot's structure, kinematics, and basic dynamics."}),"\n",(0,s.jsx)(e.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_robot">\n  \x3c!-- Links: rigid parts of the robot --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.6" radius="0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.6" radius="0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints: connections between links --\x3e\n  <link name="upper_body">\n    <visual>\n      <geometry>\n        <box size="0.3 0.3 0.6"/>\n      </geometry>\n    </visual>\n  </link>\n\n  <joint name="torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="upper_body"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"urdf-features",children:"URDF Features"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robot Structure"}),": Links and joints defining the kinematic tree"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visual Properties"}),": How the robot appears in RViz and other visualization tools"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Properties"}),": How the robot interacts with obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertial Properties"}),": Mass, center of mass, and inertia tensor for dynamics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Transmission Information"}),": How joints connect to actuators (ROS-specific)"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"urdf-limitations-for-simulation",children:"URDF Limitations for Simulation"}),"\n",(0,s.jsx)(e.p,{children:"URDF alone is insufficient for full simulation because it lacks:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World Description"}),": Environment, lighting, terrain"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Models"}),": Detailed sensor physics and noise models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Parameters"}),": Damping, friction, surface properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin Integration"}),": Custom simulation behaviors and controllers"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"sdf-the-simulation-description-format",children:"SDF: The Simulation Description Format"}),"\n",(0,s.jsx)(e.h3,{id:"sdf-overview",children:"SDF Overview"}),"\n",(0,s.jsx)(e.p,{children:"SDF is designed for complete simulation environments and is the native format for Gazebo. It encompasses everything needed for physics simulation, from robot models to world environments."}),"\n",(0,s.jsx)(e.h3,{id:"sdf-structure",children:"SDF Structure"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="default">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Models in the world --\x3e\n    <model name="my_robot">\n      \x3c!-- Pose of the model in the world --\x3e\n      <pose>0 0 0 0 0 0</pose>\n\n      \x3c!-- Links with more detailed physics --\x3e\n      <link name="base_link">\n        <pose>0 0 0 0 0 0</pose>\n\n        \x3c!-- Inertial properties --\x3e\n        <inertial>\n          <mass>10</mass>\n          <inertia>\n            <ixx>1.0</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>1.0</iyy>\n            <iyz>0.0</iyz>\n            <izz>1.0</izz>\n          </inertia>\n        </inertial>\n\n        \x3c!-- Visual properties --\x3e\n        <visual name="visual">\n          <geometry>\n            <cylinder>\n              <radius>0.2</radius>\n              <length>0.6</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0 0 0.8 1</ambient>\n            <diffuse>0 0 0.8 1</diffuse>\n          </material>\n        </visual>\n\n        \x3c!-- Collision properties --\x3e\n        <collision name="collision">\n          <geometry>\n            <cylinder>\n              <radius>0.2</radius>\n              <length>0.6</length>\n            </cylinder>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n            <bounce>\n              <restitution_coefficient>0.0</restitution_coefficient>\n              <threshold>100000</threshold>\n            </bounce>\n            <contact>\n              <ode>\n                <soft_cfm>0</soft_cfm>\n                <soft_erp>0.2</soft_erp>\n                <kp>1000000000000.0</kp>\n                <kd>1.0</kd>\n                <max_vel>0.01</max_vel>\n                <min_depth>0.001</min_depth>\n              </ode>\n            </contact>\n          </surface>\n        </collision>\n\n        \x3c!-- Sensors --\x3e\n        <sensor name="imu_sensor" type="imu">\n          <always_on>true</always_on>\n          <update_rate>100</update_rate>\n          <imu>\n            <angular_velocity>\n              <x>\n                <noise type="gaussian">\n                  <mean>0.0</mean>\n                  <stddev>0.001</stddev>\n                </noise>\n              </x>\n              <y>\n                <noise type="gaussian">\n                  <mean>0.0</mean>\n                  <stddev>0.001</stddev>\n                </noise>\n              </y>\n              <z>\n                <noise type="gaussian">\n                  <mean>0.0</mean>\n                  <stddev>0.001</stddev>\n                </noise>\n              </z>\n            </angular_velocity>\n          </imu>\n        </sensor>\n      </link>\n\n      \x3c!-- Joints --\x3e\n      <joint name="torso_joint" type="fixed">\n        <parent>base_link</parent>\n        <child>upper_body</child>\n        <pose>0 0 0.5 0 0 0</pose>\n      </joint>\n    </model>\n\n    \x3c!-- World elements --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"sdf-features",children:"SDF Features"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complete World Description"}),": Environment, physics, lighting"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Advanced Physics"}),": Detailed friction, contact, and collision models"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Integration"}),": Built-in sensor models with noise characteristics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin Architecture"}),": Extensible functionality through plugins"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-Model Support"}),": Multiple robots and objects in one environment"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"converting-urdf-to-sdf",children:"Converting URDF to SDF"}),"\n",(0,s.jsx)(e.h3,{id:"using-gazebo_ros_pkgs",children:"Using gazebo_ros_pkgs"}),"\n",(0,s.jsx)(e.p,{children:"The easiest way to use URDF models in Gazebo is through the ROS integration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:"\x3c!-- In a Gazebo world file --\x3e\n<include>\n  <name>my_robot</name>\n  <pose>0 0 0 0 0 0</pose>\n  <uri>model://my_robot_description/urdf/robot.urdf</uri>\n</include>\n"})}),"\n",(0,s.jsx)(e.h3,{id:"direct-conversion",children:"Direct Conversion"}),"\n",(0,s.jsx)(e.p,{children:"To convert URDF to SDF manually:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Convert URDF to SDF\ngz sdf -p robot.urdf > robot.sdf\n\n# Convert and specify SDF version\ngz sdf -p --in-format urdf --out-format sdf robot.urdf > robot.sdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"programmatic-conversion",children:"Programmatic Conversion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import xml.etree.ElementTree as ET\nimport subprocess\n\ndef urdf_to_sdf(urdf_file_path, sdf_file_path):\n    \"\"\"Convert URDF to SDF using gz sdf tool\"\"\"\n    try:\n        # Use gz sdf to convert\n        result = subprocess.run(\n            ['gz', 'sdf', '-p', urdf_file_path],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n\n        with open(sdf_file_path, 'w') as sdf_file:\n            sdf_file.write(result.stdout)\n\n        print(f\"Successfully converted {urdf_file_path} to {sdf_file_path}\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Error converting URDF to SDF: {e}\")\n    except FileNotFoundError:\n        print(\"Error: gz command not found. Make sure Gazebo is installed.\")\n\n# Usage\nurdf_to_sdf('robot.urdf', 'robot.sdf')\n"})}),"\n",(0,s.jsx)(e.h2,{id:"detailed-format-comparison",children:"Detailed Format Comparison"}),"\n",(0,s.jsx)(e.h3,{id:"element-mapping",children:"Element Mapping"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"URDF Element"}),(0,s.jsx)(e.th,{children:"SDF Equivalent"}),(0,s.jsx)(e.th,{children:"Notes"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<robot>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<model>"})}),(0,s.jsx)(e.td,{children:"Robot becomes a model in SDF"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<link>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<link>"})}),(0,s.jsx)(e.td,{children:"Similar structure"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<joint>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<joint>"})}),(0,s.jsx)(e.td,{children:"Similar structure"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<visual>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<visual>"})}),(0,s.jsx)(e.td,{children:"Similar structure"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<collision>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<collision>"})}),(0,s.jsx)(e.td,{children:"Enhanced with surface properties"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<inertial>"})}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.code,{children:"<inertial>"})}),(0,s.jsx)(e.td,{children:"Similar structure"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"sdf-extensions",children:"SDF Extensions"}),"\n",(0,s.jsx)(e.p,{children:"SDF includes many elements that URDF doesn't have:"}),"\n",(0,s.jsx)(e.h4,{id:"physics-extensions",children:"Physics Extensions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<collision name="collision">\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n        <fdir1>0 0 1</fdir1>\n      </ode>\n    </friction>\n    <bounce>\n      <restitution_coefficient>0.5</restitution_coefficient>\n    </bounce>\n    <contact>\n      <ode>\n        <soft_cfm>0.0</soft_cfm>\n        <soft_erp>0.2</soft_erp>\n      </ode>\n    </contact>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(e.h4,{id:"sensor-definitions",children:"Sensor Definitions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n  </camera>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <ros>\n      <namespace>camera</namespace>\n      <remapping>~/image_raw:=image</remapping>\n    </ros>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h4,{id:"plugin-integration",children:"Plugin Integration"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<model name="my_robot">\n  \x3c!-- Custom controller plugin --\x3e\n  <plugin name="diff_drive_controller" filename="libgazebo_ros_diff_drive.so">\n    <ros>\n      <namespace>diff_drive</namespace>\n    </ros>\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.3</wheel_separation>\n    <wheel_diameter>0.1</wheel_diameter>\n  </plugin>\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,s.jsx)(e.h3,{id:"complete-urdf-to-sdf-workflow",children:"Complete URDF to SDF Workflow"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Create URDF for Robot Description"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Define links, joints, and basic properties"}),"\n",(0,s.jsx)(e.li,{children:"Focus on kinematics and basic dynamics"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Create World File in SDF"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Define environment and physics"}),"\n",(0,s.jsx)(e.li,{children:"Include your robot using URDF"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- world_with_robot.sdf --\x3e\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="robot_world">\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Include robot from URDF --\x3e\n    <include>\n      <name>my_robot</name>\n      <pose>0 0 0.1 0 0 0</pose>\n      <uri>model://my_robot_description/urdf/robot.urdf</uri>\n    </include>\n\n    \x3c!-- Environment --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"advanced-sdf-features",children:"Advanced SDF Features"}),"\n",(0,s.jsx)(e.h4,{id:"custom-sensors",children:"Custom Sensors"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="custom_lidar" type="ray">\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>720</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n      <vertical>\n        <samples>1</samples>\n        <resolution>1</resolution>\n        <min_angle>0</min_angle>\n        <max_angle>0</max_angle>\n      </vertical>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n    <ros>\n      <namespace>lidar</namespace>\n      <remapping>~/out:=scan</remapping>\n    </ros>\n    <output_type>sensor_msgs/LaserScan</output_type>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h4,{id:"physics-materials",children:"Physics Materials"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<collision name="wheel_collision">\n  <surface>\n    <friction>\n      <ode>\n        <mu>10.0</mu>\n        <mu2>10.0</mu2>\n        <slip1>0.0</slip1>\n        <slip2>0.0</slip2>\n      </ode>\n      <torsional>\n        <coefficient>1.0</coefficient>\n        <use_patch_radius>false</use_patch_radius>\n        <surface_radius>0.01</surface_radius>\n      </torsional>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"tools-for-format-management",children:"Tools for Format Management"}),"\n",(0,s.jsx)(e.h3,{id:"urdf-tools",children:"URDF Tools"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Validate URDF\ncheck_urdf robot.urdf\n\n# Convert URDF to graph for visualization\nurdf_to_graphiz robot.urdf\n\n# Generate SDF from URDF\ngz sdf -p robot.urdf > robot.sdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"sdf-tools",children:"SDF Tools"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Validate SDF\ngz sdf -k world.sdf\n\n# Pretty-print SDF\ngz sdf -p world.sdf\n\n# Check for errors\ngz sdf -c world.sdf\n"})}),"\n",(0,s.jsx)(e.h3,{id:"xacro-for-both-formats",children:"Xacro for Both Formats"}),"\n",(0,s.jsx)(e.p,{children:"Xacro can be used with both URDF and SDF:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="robot_with_sensors">\n  <xacro:property name="wheel_radius" value="0.1" />\n  <xacro:property name="wheel_width" value="0.05" />\n\n  \x3c!-- Define a macro that can be used in both URDF and SDF contexts --\x3e\n  <xacro:macro name="simple_wheel" params="prefix parent x_pos y_pos z_pos">\n    <link name="${prefix}_wheel">\n      <visual>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n        <origin xyz="0 0 0" rpy="1.570796 0 0"/>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n        <origin xyz="0 0 0" rpy="1.570796 0 0"/>\n      </collision>\n      <inertial>\n        <mass value="1.0"/>\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.02"/>\n      </inertial>\n    </link>\n\n    <joint name="${prefix}_wheel_joint" type="continuous">\n      <parent link="${parent}"/>\n      <child link="${prefix}_wheel"/>\n      <origin xyz="${x_pos} ${y_pos} ${z_pos}" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Use the macro --\x3e\n  <xacro:simple_wheel prefix="front_left" parent="base_link" x_pos="0.2" y_pos="0.15" z_pos="0"/>\n  <xacro:simple_wheel prefix="front_right" parent="base_link" x_pos="0.2" y_pos="-0.15" z_pos="0"/>\n</robot>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices-for-format-usage",children:"Best Practices for Format Usage"}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-urdf",children:"When to Use URDF"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robot Description"}),": When defining robot kinematics and basic dynamics"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS Integration"}),": When working primarily within the ROS ecosystem"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visualization"}),": When using RViz for robot visualization"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Motion Planning"}),": When using MoveIt! or similar planning frameworks"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hardware Interface"}),": When connecting to real robots"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-sdf",children:"When to Use SDF"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Simulation"}),": When detailed physics simulation is required"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Simulation"}),": When using complex sensor models with noise"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World Definition"}),": When creating complex simulation environments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin Integration"}),": When using custom simulation plugins"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-Robot Simulation"}),": When simulating multiple robots together"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"combined-approach",children:"Combined Approach"}),"\n",(0,s.jsx)(e.p,{children:"The most effective approach often combines both formats:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Design Robot in URDF"}),": Create the basic robot model in URDF format"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define World in SDF"}),": Create simulation environments in SDF"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Include URDF in SDF"}),": Use URDF models within SDF worlds"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Add SDF Extensions"}),": Add sensors and physics properties in the SDF context"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"example-workflow",children:"Example Workflow"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# 1. Create and validate URDF\ncheck_urdf robot.urdf\n\n# 2. Use URDF in SDF world\ngz sim -r robot_world.sdf\n\n# 3. Test and refine both formats\n# 4. Use Xacro to manage complexity in both formats\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-format-conversion-and-integration",children:"Exercise: Format Conversion and Integration"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Take a simple robot URDF file (like the one from Module 1)"}),"\n",(0,s.jsx)(e.li,{children:"Create a Gazebo world file that includes your robot"}),"\n",(0,s.jsx)(e.li,{children:"Add a simple sensor (camera or LiDAR) to the robot in the SDF world"}),"\n",(0,s.jsx)(e.li,{children:"Launch the simulation and verify the robot appears correctly"}),"\n",(0,s.jsx)(e.li,{children:"Experiment with different physics parameters"}),"\n",(0,s.jsx)(e.li,{children:"Create a launch file that starts Gazebo with your world"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This exercise will help you understand the relationship between URDF and SDF and how to use both effectively."}),"\n",(0,s.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,s.jsx)(e.h3,{id:"urdf-to-sdf-conversion-issues",children:"URDF to SDF Conversion Issues"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Missing elements"}),": SDF may not preserve all URDF extensions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Coordinate system differences"}),": Check frame conventions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Inertia issues"}),": Verify mass and inertia values transfer correctly"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"simulation-issues",children:"Simulation Issues"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics instability"}),": Adjust physics parameters in SDF"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Joint constraints"}),": Verify joint limits and types"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision issues"}),": Check collision geometries and properties"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"integration-issues",children:"Integration Issues"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS topic names"}),": Ensure proper namespace and topic mapping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Frame transforms"}),": Verify TF tree structure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin loading"}),": Check plugin dependencies and paths"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"URDF and SDF serve complementary but distinct purposes in robotics. URDF excels at robot description for ROS integration and kinematic analysis, while SDF provides comprehensive simulation capabilities for physics, sensors, and environments. Understanding both formats and how to work with them together is essential for effective robotics simulation and development."}),"\n",(0,s.jsx)(e.p,{children:"The key is to leverage each format's strengths: use URDF for robot description and ROS integration, and SDF for simulation environments and advanced physics modeling. Together, they form a complete solution for robotics simulation and development."}),"\n",(0,s.jsx)(e.p,{children:"In the next section, we'll explore how to simulate various sensors in digital environments, building on the format knowledge we've gained."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);