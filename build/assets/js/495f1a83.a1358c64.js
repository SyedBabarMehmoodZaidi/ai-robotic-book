"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[622],{2523:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=i(4848),t=i(8453);const r={sidebar_position:2},o="ROS 2 Architecture: Nodes, Topics, Services, and Actions",a={id:"module-1-ros2/architecture",title:"ROS 2 Architecture: Nodes, Topics, Services, and Actions",description:"Learning Objectives",source:"@site/docs/module-1-ros2/architecture.md",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/architecture",permalink:"/ai-robotic-book/docs/module-1-ros2/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/ai-robotic-book/tree/main/docs/module-1-ros2/architecture.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Module 1: The Robotic Nervous System (ROS 2)",permalink:"/ai-robotic-book/docs/module-1-ros2/"},next:{title:"Python Agent Integration with ROS Controllers using rclpy",permalink:"/ai-robotic-book/docs/module-1-ros2/python-integration"}},c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to ROS 2 Architecture",id:"introduction-to-ros-2-architecture",level:2},{value:"Nodes",id:"nodes",level:2},{value:"What is a Node?",id:"what-is-a-node",level:3},{value:"Node Characteristics",id:"node-characteristics",level:3},{value:"Creating a Node",id:"creating-a-node",level:3},{value:"Topics",id:"topics",level:2},{value:"What is a Topic?",id:"what-is-a-topic",level:3},{value:"Topic Characteristics",id:"topic-characteristics",level:3},{value:"Example: Sensor Data Topic",id:"example-sensor-data-topic",level:3},{value:"Services",id:"services",level:2},{value:"What is a Service?",id:"what-is-a-service",level:3},{value:"Service Characteristics",id:"service-characteristics",level:3},{value:"Example: Navigation Service",id:"example-navigation-service",level:3},{value:"Actions",id:"actions",level:2},{value:"What is an Action?",id:"what-is-an-action",level:3},{value:"Action Characteristics",id:"action-characteristics",level:3},{value:"Example: Navigation Action",id:"example-navigation-action",level:3},{value:"Communication Pattern Selection Guide",id:"communication-pattern-selection-guide",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Node Design",id:"node-design",level:3},{value:"Topic Usage",id:"topic-usage",level:3},{value:"Service Design",id:"service-design",level:3},{value:"Action Implementation",id:"action-implementation",level:3},{value:"Exercise: Understanding Communication Patterns",id:"exercise-understanding-communication-patterns",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"ros-2-architecture-nodes-topics-services-and-actions",children:"ROS 2 Architecture: Nodes, Topics, Services, and Actions"}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explain the fundamental components of ROS 2 architecture"}),"\n",(0,s.jsx)(n.li,{children:"Distinguish between Nodes, Topics, Services, and Actions"}),"\n",(0,s.jsx)(n.li,{children:"Understand when to use each communication pattern"}),"\n",(0,s.jsx)(n.li,{children:"Create basic examples of each communication type"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-ros-2-architecture",children:"Introduction to ROS 2 Architecture"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 (Robot Operating System 2) provides a flexible framework for writing robot software. It is a collection of libraries, tools, and conventions that enable different software components to communicate with each other. Understanding the architecture is crucial for developing effective robotic systems."}),"\n",(0,s.jsx)(n.p,{children:"The ROS 2 architecture is built around several core concepts that work together to enable communication, coordination, and control of robotic systems. These components form the backbone of any ROS 2 application."}),"\n",(0,s.jsx)(n.h2,{id:"nodes",children:"Nodes"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-node",children:"What is a Node?"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"Node"}),' is the fundamental unit of computation in ROS 2. It\'s an executable process that performs specific computations and communicates with other nodes. Think of nodes as the "cells" in the robotic nervous system - each one performs a specific function while working together as part of a larger system.']}),"\n",(0,s.jsx)(n.h3,{id:"node-characteristics",children:"Node Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Process"}),": Each node runs as a separate process"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Communication"}),": Nodes communicate with other nodes through topics, services, and actions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsibility"}),": Each node typically has a single responsibility (e.g., sensor processing, control algorithm, visualization)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle"}),": Nodes can be started, stopped, and managed independently"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-node",children:"Creating a Node"}),"\n",(0,s.jsx)(n.p,{children:"In Python using rclpy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MyRobotNode(Node):\n    def __init__(self):\n        super().__init__('my_robot_node')\n        self.get_logger().info('MyRobotNode has been started')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MyRobotNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"topics",children:"Topics"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-topic",children:"What is a Topic?"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"Topic"})," is a named bus over which nodes exchange messages. Topics implement a publish-subscribe communication pattern where publishers send messages and subscribers receive messages. This is ideal for continuous data streams like sensor data or robot state information."]}),"\n",(0,s.jsx)(n.h3,{id:"topic-characteristics",children:"Topic Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous"}),": Publishers and subscribers don't need to be synchronized"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Many-to-many"}),": Multiple publishers can send to a topic, and multiple subscribers can receive from it"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unidirectional"}),": Data flows in one direction (publisher \u2192 topic \u2192 subscriber)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Typed"}),": Each topic has a specific message type that defines its structure"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-sensor-data-topic",children:"Example: Sensor Data Topic"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\n\nclass SensorNode(Node):\n    def __init__(self):\n        super().__init__('sensor_node')\n        self.publisher = self.create_publisher(LaserScan, 'laser_scan', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = LaserScan()\n        # Fill in message data\n        msg.ranges = [1.0, 2.0, 3.0]  # Example ranges\n        self.publisher.publish(msg)\n        self.get_logger().info('Publishing laser scan data')\n\nclass ProcessingNode(Node):\n    def __init__(self):\n        super().__init__('processing_node')\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'laser_scan',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received laser scan with {len(msg.ranges)} readings')\n"})}),"\n",(0,s.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-service",children:"What is a Service?"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"Service"})," provides a request-response communication pattern. A service client sends a request and waits for a response from a service server. This is ideal for operations that require immediate results, such as changing robot parameters or triggering specific actions."]}),"\n",(0,s.jsx)(n.h3,{id:"service-characteristics",children:"Service Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synchronous"}),": Client waits for response from server"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"One-to-one"}),": One client requests from one server at a time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bidirectional"}),": Request goes to server, response comes back to client"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Blocking"}),": Client blocks until response is received (unless using async)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-navigation-service",children:"Example: Navigation Service"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool\n\nclass NavigationServer(Node):\n    def __init__(self):\n        super().__init__('navigation_server')\n        self.srv = self.create_service(\n            SetBool,\n            'enable_navigation',\n            self.enable_navigation_callback)\n\n    def enable_navigation_callback(self, request, response):\n        if request.data:\n            self.get_logger().info('Navigation enabled')\n            response.success = True\n            response.message = 'Navigation system enabled'\n        else:\n            self.get_logger().info('Navigation disabled')\n            response.success = True\n            response.message = 'Navigation system disabled'\n        return response\n\nclass NavigationClient(Node):\n    def __init__(self):\n        super().__init__('navigation_client')\n        self.cli = self.create_client(SetBool, 'enable_navigation')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = SetBool.Request()\n\n    def send_request(self, enable):\n        self.req.data = enable\n        future = self.cli.call_async(self.req)\n        return future\n"})}),"\n",(0,s.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-an-action",children:"What is an Action?"}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.strong,{children:"Action"})," is a goal-oriented communication pattern that extends services to support long-running operations. Actions include feedback during execution and the ability to cancel ongoing operations. This is ideal for tasks like navigation to a goal or manipulation operations."]}),"\n",(0,s.jsx)(n.h3,{id:"action-characteristics",children:"Action Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Long-running"}),": Designed for operations that take significant time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feedback"}),": Provides intermediate feedback during execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cancel"}),": Allows clients to cancel ongoing operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Status"}),": Tracks the status of the goal (pending, active, succeeded, etc.)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-navigation-action",children:"Example: Navigation Action"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nimport time\n\nclass NavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('navigation_action_server')\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            execute_callback=self.execute_callback,\n            cancel_callback=self.cancel_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing navigation goal...')\n\n        # Simulate navigation progress\n        for i in range(10):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return NavigateToPose.Result()\n\n            # Publish feedback\n            feedback_msg = NavigateToPose.Feedback()\n            feedback_msg.distance_remaining = 10.0 - i\n            goal_handle.publish_feedback(feedback_msg)\n\n            time.sleep(1)  # Simulate navigation time\n\n        goal_handle.succeed()\n        result = NavigateToPose.Result()\n        result.result = True\n        return result\n\n    def cancel_callback(self, goal_handle):\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n"})}),"\n",(0,s.jsx)(n.h2,{id:"communication-pattern-selection-guide",children:"Communication Pattern Selection Guide"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Communication Pattern"}),(0,s.jsx)(n.th,{children:"Reason"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sensor data streaming"}),(0,s.jsx)(n.td,{children:"Topic"}),(0,s.jsx)(n.td,{children:"Continuous, asynchronous data flow"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Robot state monitoring"}),(0,s.jsx)(n.td,{children:"Topic"}),(0,s.jsx)(n.td,{children:"Multiple subscribers need the same information"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Parameter updates"}),(0,s.jsx)(n.td,{children:"Service"}),(0,s.jsx)(n.td,{children:"Request-response pattern, immediate result needed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Triggering specific actions"}),(0,s.jsx)(n.td,{children:"Service"}),(0,s.jsx)(n.td,{children:"Simple, synchronous operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Navigation to goal"}),(0,s.jsx)(n.td,{children:"Action"}),(0,s.jsx)(n.td,{children:"Long-running, needs feedback and cancel capability"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Manipulation tasks"}),(0,s.jsx)(n.td,{children:"Action"}),(0,s.jsx)(n.td,{children:"Complex, long-running operations with status"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Control commands"}),(0,s.jsx)(n.td,{children:"Topic"}),(0,s.jsx)(n.td,{children:"Fast, continuous command updates"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"node-design",children:"Node Design"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep nodes focused on a single responsibility"}),"\n",(0,s.jsx)(n.li,{children:"Use descriptive names that indicate the node's function"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper error handling and logging"}),"\n",(0,s.jsx)(n.li,{children:"Consider the node's lifecycle and resource management"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"topic-usage",children:"Topic Usage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use appropriate message types for your data"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate queue sizes based on your application's needs"}),"\n",(0,s.jsx)(n.li,{children:"Consider the frequency of message publishing"}),"\n",(0,s.jsx)(n.li,{children:"Use reliable QoS for critical data, best-effort for less critical data"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-design",children:"Service Design"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep service operations relatively quick"}),"\n",(0,s.jsx)(n.li,{children:"Design clear request and response message structures"}),"\n",(0,s.jsx)(n.li,{children:"Handle errors gracefully and provide meaningful error messages"}),"\n",(0,s.jsx)(n.li,{children:"Consider if an action might be more appropriate for long-running operations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"action-implementation",children:"Action Implementation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provide meaningful feedback during long operations"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper cancellation handling"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate timeouts for operations"}),"\n",(0,s.jsx)(n.li,{children:"Consider the state management for complex actions"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercise-understanding-communication-patterns",children:"Exercise: Understanding Communication Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Create a simple ROS 2 system with the following components:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A sensor node that publishes temperature data to a topic"}),"\n",(0,s.jsx)(n.li,{children:"A logger node that subscribes to the temperature topic and logs values"}),"\n",(0,s.jsx)(n.li,{children:"A service server that converts Celsius to Fahrenheit"}),"\n",(0,s.jsx)(n.li,{children:"A service client that requests temperature conversion"}),"\n",(0,s.jsx)(n.li,{children:"An action server that simulates a heating/cooling process"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This exercise will help you understand the differences between the various communication patterns and when to use each one."}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2's architecture provides flexible communication patterns that enable the development of complex robotic systems. Understanding when and how to use nodes, topics, services, and actions is fundamental to creating effective robot applications. Each pattern serves specific purposes and choosing the right one for your use case is crucial for system performance and maintainability."}),"\n",(0,s.jsx)(n.p,{children:"In the next section, we'll explore how to implement these concepts using Python and the rclpy library."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);